{"version":3,"names":["Object","defineProperty","exports","value","default","_utils","_interopRequireDefault","require","_parseHeaders","e","__esModule","$internals","Symbol","normalizeHeader","header","String","trim","toLowerCase","normalizeValue","utils","isArray","map","parseTokens","str","tokens","create","tokensRE","match","exec","isValidHeaderName","test","matchHeaderValue","context","filter","isHeaderNameFilter","isFunction","call","isString","indexOf","isRegExp","formatHeader","replace","w","char","toUpperCase","buildAccessors","obj","accessorName","toCamelCase","forEach","methodName","arg1","arg2","arg3","configurable","AxiosHeaders","constructor","headers","set","valueOrRewrite","rewrite","self","setHeader","_value","_header","_rewrite","lHeader","Error","key","findKey","undefined","setHeaders","isPlainObject","parseHeaders","isObject","isIterable","dest","entry","TypeError","get","parser","has","matcher","delete","deleted","deleteHeader","clear","keys","i","length","normalize","format","normalized","concat","targets","toJSON","asStrings","join","iterator","entries","toString","getSetCookie","toStringTag","from","thing","first","computed","target","accessor","internals","accessors","prototype","defineAccessor","reduceDescriptors","mapped","slice","headerValue","freezeMethods","_default"],"sources":["AxiosHeaders.js"],"sourcesContent":["'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isObject(header) && utils.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils.isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n"],"mappings":"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","ignoreList":[]}