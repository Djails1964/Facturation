51c62a3e9702b63f40e948825b4000e2
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForElementToBeRemoved = waitForElementToBeRemoved;
var _waitFor = require("./wait-for");
const isRemoved = result => !result || Array.isArray(result) && !result.length;

// Check if the element is not present.
// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`
function initialCheck(elements) {
  if (isRemoved(elements)) {
    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');
  }
}
async function waitForElementToBeRemoved(callback, options) {
  // created here so we get a nice stacktrace
  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');
  if (typeof callback !== 'function') {
    initialCheck(callback);
    const elements = Array.isArray(callback) ? callback : [callback];
    const getRemainingElements = elements.map(element => {
      let parent = element.parentElement;
      if (parent === null) return () => null;
      while (parent.parentElement) parent = parent.parentElement;
      return () => parent.contains(element) ? element : null;
    });
    callback = () => getRemainingElements.map(c => c()).filter(Boolean);
  }
  initialCheck(callback());
  return (0, _waitFor.waitFor)(() => {
    let result;
    try {
      result = callback();
    } catch (error) {
      if (error.name === 'TestingLibraryElementError') {
        return undefined;
      }
      throw error;
    }
    if (!isRemoved(result)) {
      throw timeoutError;
    }
    return undefined;
  }, options);
}

/*
eslint
  require-await: "off"
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQiLCJfd2FpdEZvciIsInJlcXVpcmUiLCJpc1JlbW92ZWQiLCJyZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpbml0aWFsQ2hlY2siLCJlbGVtZW50cyIsIkVycm9yIiwiY2FsbGJhY2siLCJvcHRpb25zIiwidGltZW91dEVycm9yIiwiZ2V0UmVtYWluaW5nRWxlbWVudHMiLCJtYXAiLCJlbGVtZW50IiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImNvbnRhaW5zIiwiYyIsImZpbHRlciIsIkJvb2xlYW4iLCJ3YWl0Rm9yIiwiZXJyb3IiLCJuYW1lIiwidW5kZWZpbmVkIl0sInNvdXJjZXMiOlsid2FpdC1mb3ItZWxlbWVudC10by1iZS1yZW1vdmVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy53YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkID0gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZDtcbnZhciBfd2FpdEZvciA9IHJlcXVpcmUoXCIuL3dhaXQtZm9yXCIpO1xuY29uc3QgaXNSZW1vdmVkID0gcmVzdWx0ID0+ICFyZXN1bHQgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQpICYmICFyZXN1bHQubGVuZ3RoO1xuXG4vLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBub3QgcHJlc2VudC5cbi8vIEFzIHRoZSBuYW1lIGltcGxpZXMsIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgc2hvdWxkIGNoZWNrIGBwcmVzZW50YCAtLT4gYHJlbW92ZWRgXG5mdW5jdGlvbiBpbml0aWFsQ2hlY2soZWxlbWVudHMpIHtcbiAgaWYgKGlzUmVtb3ZlZChlbGVtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbGVtZW50KHMpIGdpdmVuIHRvIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgYXJlIGFscmVhZHkgcmVtb3ZlZC4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZCByZXF1aXJlcyB0aGF0IHRoZSBlbGVtZW50KHMpIGV4aXN0KHMpIGJlZm9yZSB3YWl0aW5nIGZvciByZW1vdmFsLicpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZWQgaGVyZSBzbyB3ZSBnZXQgYSBuaWNlIHN0YWNrdHJhY2VcbiAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCdUaW1lZCBvdXQgaW4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZC4nKTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGluaXRpYWxDaGVjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5pc0FycmF5KGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogW2NhbGxiYWNrXTtcbiAgICBjb25zdCBnZXRSZW1haW5pbmdFbGVtZW50cyA9IGVsZW1lbnRzLm1hcChlbGVtZW50ID0+IHtcbiAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gKCkgPT4gbnVsbDtcbiAgICAgIHdoaWxlIChwYXJlbnQucGFyZW50RWxlbWVudCkgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gKCkgPT4gcGFyZW50LmNvbnRhaW5zKGVsZW1lbnQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgfSk7XG4gICAgY2FsbGJhY2sgPSAoKSA9PiBnZXRSZW1haW5pbmdFbGVtZW50cy5tYXAoYyA9PiBjKCkpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBpbml0aWFsQ2hlY2soY2FsbGJhY2soKSk7XG4gIHJldHVybiAoMCwgX3dhaXRGb3Iud2FpdEZvcikoKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVGVzdGluZ0xpYnJhcnlFbGVtZW50RXJyb3InKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKCFpc1JlbW92ZWQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgdGltZW91dEVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBvcHRpb25zKTtcbn1cblxuLypcbmVzbGludFxuICByZXF1aXJlLWF3YWl0OiBcIm9mZlwiXG4qLyJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFDM0NDLEtBQUssRUFBRTtBQUNULENBQUMsQ0FBQztBQUNGRCxPQUFPLENBQUNFLHlCQUF5QixHQUFHQSx5QkFBeUI7QUFDN0QsSUFBSUMsUUFBUSxHQUFHQyxPQUFPLGFBQWEsQ0FBQztBQUNwQyxNQUFNQyxTQUFTLEdBQUdDLE1BQU0sSUFBSSxDQUFDQSxNQUFNLElBQUlDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDRixNQUFNLENBQUMsSUFBSSxDQUFDQSxNQUFNLENBQUNHLE1BQU07O0FBRTlFO0FBQ0E7QUFDQSxTQUFTQyxZQUFZQSxDQUFDQyxRQUFRLEVBQUU7RUFDOUIsSUFBSU4sU0FBUyxDQUFDTSxRQUFRLENBQUMsRUFBRTtJQUN2QixNQUFNLElBQUlDLEtBQUssQ0FBQyxvS0FBb0ssQ0FBQztFQUN2TDtBQUNGO0FBQ0EsZUFBZVYseUJBQXlCQSxDQUFDVyxRQUFRLEVBQUVDLE9BQU8sRUFBRTtFQUMxRDtFQUNBLE1BQU1DLFlBQVksR0FBRyxJQUFJSCxLQUFLLENBQUMseUNBQXlDLENBQUM7RUFDekUsSUFBSSxPQUFPQyxRQUFRLEtBQUssVUFBVSxFQUFFO0lBQ2xDSCxZQUFZLENBQUNHLFFBQVEsQ0FBQztJQUN0QixNQUFNRixRQUFRLEdBQUdKLEtBQUssQ0FBQ0MsT0FBTyxDQUFDSyxRQUFRLENBQUMsR0FBR0EsUUFBUSxHQUFHLENBQUNBLFFBQVEsQ0FBQztJQUNoRSxNQUFNRyxvQkFBb0IsR0FBR0wsUUFBUSxDQUFDTSxHQUFHLENBQUNDLE9BQU8sSUFBSTtNQUNuRCxJQUFJQyxNQUFNLEdBQUdELE9BQU8sQ0FBQ0UsYUFBYTtNQUNsQyxJQUFJRCxNQUFNLEtBQUssSUFBSSxFQUFFLE9BQU8sTUFBTSxJQUFJO01BQ3RDLE9BQU9BLE1BQU0sQ0FBQ0MsYUFBYSxFQUFFRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0MsYUFBYTtNQUMxRCxPQUFPLE1BQU1ELE1BQU0sQ0FBQ0UsUUFBUSxDQUFDSCxPQUFPLENBQUMsR0FBR0EsT0FBTyxHQUFHLElBQUk7SUFDeEQsQ0FBQyxDQUFDO0lBQ0ZMLFFBQVEsR0FBR0EsQ0FBQSxLQUFNRyxvQkFBb0IsQ0FBQ0MsR0FBRyxDQUFDSyxDQUFDLElBQUlBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLENBQUM7RUFDckU7RUFDQWQsWUFBWSxDQUFDRyxRQUFRLENBQUMsQ0FBQyxDQUFDO0VBQ3hCLE9BQU8sQ0FBQyxDQUFDLEVBQUVWLFFBQVEsQ0FBQ3NCLE9BQU8sRUFBRSxNQUFNO0lBQ2pDLElBQUluQixNQUFNO0lBQ1YsSUFBSTtNQUNGQSxNQUFNLEdBQUdPLFFBQVEsQ0FBQyxDQUFDO0lBQ3JCLENBQUMsQ0FBQyxPQUFPYSxLQUFLLEVBQUU7TUFDZCxJQUFJQSxLQUFLLENBQUNDLElBQUksS0FBSyw0QkFBNEIsRUFBRTtRQUMvQyxPQUFPQyxTQUFTO01BQ2xCO01BQ0EsTUFBTUYsS0FBSztJQUNiO0lBQ0EsSUFBSSxDQUFDckIsU0FBUyxDQUFDQyxNQUFNLENBQUMsRUFBRTtNQUN0QixNQUFNUyxZQUFZO0lBQ3BCO0lBQ0EsT0FBT2EsU0FBUztFQUNsQixDQUFDLEVBQUVkLE9BQU8sQ0FBQztBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiaWdub3JlTGlzdCI6W119