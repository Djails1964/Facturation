import { useState, useCallback, useRef, useEffect } from 'react';

/**
 * Hook personnalis√© pour la gestion des calculs de prix dans les factures
 * VERSION CORRIG√âE - Extraction des IDs CORRIG√âE
 */
export function useFacturePricing(
    client,
    tarificationService,
    services,
    unites,
    lignes,
    modifierLigne,
    prixModifiesManuel
) {
    // √âtats pour le suivi des calculs
    const [isCalculating, setIsCalculating] = useState(false);
    const [lastCalculation, setLastCalculation] = useState({});
    
    // R√©f√©rences pour √©viter les calculs multiples
    const calculationCache = useRef(new Map());
    const calculationPromises = useRef(new Map());
    
    /**
     * ‚úÖ FONCTION PRINCIPALE CORRIG√âE: Calcul du prix pour un client
     */
    const calculerPrixPourClient = useCallback(async (params) => {
        const { clientId, idService, idUnite, forceRecalcul = false } = params;

        console.log('üîç calculerPrixPourClient appel√© avec:', { clientId, idService, idUnite, forceRecalcul });
        
        // Validation stricte des param√®tres
        if (!clientId || !idService || !idUnite) {
            console.warn('‚ùå Param√®tres manquants pour calculerPrixPourClient:', { clientId, idService, idUnite });
            return 0;
        }

        if (!tarificationService) {
            console.warn('‚ùå TarificationService non disponible');
            return 0;
        }

        // Cl√© de cache
        const cacheKey = `${clientId}-${idService}-${idUnite}`;

        // ‚úÖ CORRECTION PRINCIPALE: Force recalcul ou v√©rification cache
        if (!forceRecalcul) {
            // V√©rifier le cache seulement si pas de force
            if (calculationCache.current.has(cacheKey)) {
                const cachedResult = calculationCache.current.get(cacheKey);
                const now = Date.now();
                
                // ‚úÖ R√©duire le d√©lai de cache √† 10 secondes pour plus de r√©activit√©
                if (now - cachedResult.timestamp < 10000) {
                    console.log(`üìã Prix r√©cup√©r√© du cache: ${cachedResult.prix} CHF pour ${cacheKey}`);
                    return cachedResult.prix;
                } else {
                    // Cache expir√©, le supprimer
                    calculationCache.current.delete(cacheKey);
                    console.log(`üïê Cache expir√© pour ${cacheKey}, recalcul n√©cessaire`);
                }
            }
        } else {
            // Force recalcul - nettoyer le cache pour cette combinaison
            calculationCache.current.delete(cacheKey);
            console.log(`üîÑ Force recalcul demand√© pour ${cacheKey}`);
        }

        // Protection contre les appels simultan√©s
        if (calculationPromises.current.has(cacheKey)) {
            console.log(`‚è≥ Calcul d√©j√† en cours pour ${cacheKey}, attente du r√©sultat...`);
            return await calculationPromises.current.get(cacheKey);
        }

        // Cr√©er la promesse de calcul
        const calculationPromise = (async () => {
            try {
                console.log('üí∞ Calcul du prix initial pour:', {
                    clientId,
                    idService,
                    idUnite,
                    clientNom: client?.nom,
                    forceRecalcul
                });

                const prix = await tarificationService.calculerPrix({
                    clientId,
                    idService, // ‚úÖ CORRECTION: utiliser serviceId au lieu d'idService
                    idUnite,    // ‚úÖ CORRECTION: utiliser uniteId au lieu d'idUnite
                    date: new Date().toISOString().split('T')[0]
                });

                const finalPrix = prix || 0;
                
                // Mise en cache du r√©sultat
                calculationCache.current.set(cacheKey, {
                    prix: finalPrix,
                    timestamp: Date.now()
                });

                console.log(`üìä Prix calcul√©: ${finalPrix} CHF pour client ${client?.nom} (ID: ${clientId})`);
                return finalPrix;
            } catch (error) {
                console.error('‚ùå Erreur dans calculerPrixPourClient:', error);
                return 0;
            } finally {
                // Nettoyer la promesse
                calculationPromises.current.delete(cacheKey);
            }
        })();

        // Stocker la promesse
        calculationPromises.current.set(cacheKey, calculationPromise);
        
        return await calculationPromise;
    }, [tarificationService, client]);

    /**
     * ‚úÖ Calcul automatique des prix manquants pour toutes les lignes - LOGIQUE CORRIG√âE
     */
    const calculerPrixManquants = useCallback(async () => {
        if (!client || !lignes?.length || !tarificationService || isCalculating) {
            return;
        }

        const lignesSansPrix = lignes.filter((ligne, index) => {
            return ligne.prixUnitaire === 0 || ligne.prixUnitaire === '';
        });

        if (lignesSansPrix.length === 0) {
            console.log('‚úÖ Toutes les lignes ont d√©j√† un prix');
            return;
        }

        console.log(`üîÑ D√©tection de ${lignesSansPrix.length} ligne(s) sans prix, calcul automatique`);
        setIsCalculating(true);

        try {
            for (let i = 0; i < lignes.length; i++) {
                const ligne = lignes[i];
                
                // Ignorer les lignes qui ont d√©j√† un prix ou dont le prix a √©t√© modifi√© manuellement
                if ((ligne.prixUnitaire > 0) || prixModifiesManuel?.current?.[i]) {
                    continue;
                }

                console.log(`üé® Interface mise √† jour pour ligne ${i}`);
                
                // ‚úÖ CORRECTION PRINCIPALE: Extraction des IDs depuis les objets enrichis
                let idService = null;
                let idUnite = null;

                console.log(`üîç Extraction des IDs pour ligne ${i}:`, {
                    idService,
                    idUnite
                });
                console.log('Donn√©es de la ligne:', ligne);

                // ‚úÖ CORRECTION: Extraction du service - ORDRE MODIFI√â
                if (ligne.service && typeof ligne.service === 'object' && ligne.service.idService) {
                    idService = ligne.service.idService;
                    console.log('‚úÖ Service ID extrait depuis objet enrichi:', idService);
                } else if (ligne.serviceId) {
                    idService = ligne.serviceId;
                    console.log('‚úÖ Service ID extrait depuis propri√©t√© directe:', idService);
                } else if (ligne.serviceType && services) {
                    const serviceObj = services.find(s => s.codeService === ligne.serviceType);
                    idService = serviceObj?.idService;
                    console.log('‚úÖ Service ID extrait par recherche code:', idService);
                }

                // ‚úÖ CORRECTION: Extraction de l'unit√© - ORDRE MODIFI√â
                if (ligne.unite && typeof ligne.unite === 'object' && ligne.unite.idUnite) {
                    idUnite = ligne.unite.idUnite;
                    console.log('‚úÖ Unit√© ID extraite depuis objet enrichi:', idUnite);
                } else if (ligne.uniteId) {
                    idUnite = ligne.uniteId;
                    console.log('‚úÖ Unit√© ID extraite depuis propri√©t√© directe:', idUnite);
                } else if (ligne.uniteCode && unites) {
                    const uniteObj = unites.find(u => u.codeUnite === ligne.uniteCode || u.code === ligne.uniteCode);
                    idUnite = uniteObj?.idUnite;
                    console.log('‚úÖ Unit√© ID extraite par recherche code:', idUnite);
                } else if (typeof ligne.unite === 'string' && unites) {
                    const uniteObj = unites.find(u => u.codeUnite === ligne.unite || u.code === ligne.unite);
                    idUnite = uniteObj?.idUnite;
                    console.log('‚úÖ Unit√© ID extraite par recherche string:', idUnite);
                }

                console.log(`üîç IDs finaux pour ligne ${i}:`, { idService, idUnite });

                if (!idService || !idUnite) {
                    console.warn(`‚ö†Ô∏è IDs manquants pour ligne ${i}:`, { idService, idUnite });
                    continue;
                }

                console.log(`üí∞ Calcul prix manquant pour ligne ${i}:`, { 
                    service: ligne.service?.codeService || ligne.serviceType, 
                    unite: ligne.unite?.codeUnite || ligne.uniteCode || ligne.unite 
                });

                try {
                    const prix = await calculerPrixPourClient({
                        clientId: client.id,
                        idService,
                        idUnite,
                        forceRecalcul: true // ‚úÖ Force le recalcul
                    });

                    if (prix > 0 && modifierLigne && typeof modifierLigne === 'function') {
                        modifierLigne(i, 'prixUnitaire', prix);
                        console.log(`‚úÖ Prix appliqu√©: ${prix} CHF pour ligne ${i}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Erreur calcul prix ligne ${i}:`, error);
                }
            }
        } catch (error) {
            console.error('‚ùå Erreur dans calculerPrixManquants:', error);
        } finally {
            setIsCalculating(false);
        }
    }, [client, lignes, tarificationService, isCalculating, services, unites, calculerPrixPourClient, modifierLigne, prixModifiesManuel]);

    /**
     * Calcul du prix pour un service et une unit√© sp√©cifiques
     */
    const calculerPrixPourServiceUnite = useCallback(async (serviceCode, uniteCode) => {
        if (!client || !serviceCode || !uniteCode || !services || !unites) {
            return 0;
        }

        const service = services.find(s => s.codeService === serviceCode);
        const unite = unites.find(u => u.code === uniteCode || u.codeUnite === uniteCode);

        if (!service || !unite) {
            console.warn('Service ou unit√© non trouv√©:', { serviceCode, uniteCode });
            return 0;
        }

        return await calculerPrixPourClient({
            clientId: client.id,
            idService: service.idService,
            idUnite: unite.idUnite
        });
    }, [client, services, unites, calculerPrixPourClient]);

    /**
     * V√©rification si un prix est en cours de calcul
     */
    const isPrixCalculating = useCallback((serviceId, uniteId) => {
        if (!client) return false;
        const cacheKey = `${client.id}-${serviceId}-${uniteId}`;
        return calculationPromises.current.has(cacheKey);
    }, [client]);

    /**
     * Nettoyage du cache
     */
    const clearCache = useCallback(() => {
        calculationCache.current.clear();
        calculationPromises.current.clear();
        console.log('üßπ Cache des prix nettoy√©');
    }, []);

    /**
     * Obtention du tarif d'information pour un client
     */
    const getTarifInfo = useCallback(async () => {
        if (!client || !tarificationService) {
            return '';
        }

        try {
            return await tarificationService.getTarifInfoMessage(client);
        } catch (error) {
            console.error('Erreur lors de la r√©cup√©ration du tarif info:', error);
            return '';
        }
    }, [client, tarificationService]);

    /**
     * Validation qu'un prix est valide
     */
    const isValidPrice = useCallback((prix) => {
        return typeof prix === 'number' && prix >= 0 && !isNaN(prix);
    }, []);

    /**
     * Formatage d'un prix pour affichage
     */
    const formatPrice = useCallback((prix) => {
        if (!isValidPrice(prix)) return '0.00';
        return prix.toFixed(2);
    }, [isValidPrice]);

    /**
     * Effet pour d√©clencher le calcul automatique des prix manquants
     */
    useEffect(() => {
        if (!client || !lignes?.length || !tarificationService) {
            return;
        }

        // D√©lai pour √©viter les calculs excessifs
        const timer = setTimeout(() => {
            calculerPrixManquants();
        }, 300);

        return () => clearTimeout(timer);
    }, [client?.id, lignes?.length, tarificationService, calculerPrixManquants]);

    /**
     * Nettoyage lors du changement de client
     */
    useEffect(() => {
        if (client?.id !== lastCalculation.clientId) {
            clearCache();
            setLastCalculation({ 
                clientId: client?.id, 
                timestamp: Date.now() 
            });
        }
    }, [client?.id, lastCalculation.clientId, clearCache]);

    /**
     * Nettoyage lors du d√©montage
     */
    useEffect(() => {
        return () => {
            clearCache();
        };
    }, [clearCache]);

    return {
        // Fonctions principales
        calculerPrixPourClient,
        calculerPrixManquants,
        calculerPrixPourServiceUnite,
        
        // Utilitaires
        getTarifInfo,
        isPrixCalculating,
        clearCache,
        isValidPrice,
        formatPrice,
        
        // √âtats
        isCalculating,
        lastCalculation
    };
}